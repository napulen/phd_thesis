\guide{Data augmentation}

\guide{Transposition}

As in most automatic tonal music analysis research, we
transpose each piece to different keys as a means for data
augmentation. Particularly, we transpose to all the keys
that lie within a range of key signatures in both modes.
When we transpose a piece, we verify that all the
modulations within the piece fall in the target range of key
signatures. This process of transposition and data
augmentation was introduced and described by Micchi et al.
\parencite{micchi2020not}. In our data exploration, we found
G$\sharp$ major to be the furthest key to the center of the
\emph{line-of-fifths} \parencite{temperley2000line} in the
dataset. Thus, we transposed in the range of keys within 8
flats to 8 sharps in their key signature.
% Due to modulations, two pieces of music may be transposed
% a different number of times. Generally, chromatic pieces
% (passing through many different keys) can be transposed to
% fewer new keys, while more diatonic pieces (which remain
% in one or few key/s) can be transposed more.

\guide{Synthetic examples}

\guide{Additional data augmentation.}
In addition to transposition, we implemented a variation of
a recent data-augmentation technique proposed by N\'apoles
L\'opez and Fujinaga \parencite{napoleslopez2020harmonic}.
Starting with the Roman numeral analyses of our dataset, we
synthesized `new' training examples by realizing the chords
implied by each Roman numeral annotation. The synthesis was
done using the music21 Python library
\parencite{cuthbert_music21_2010}, which converts RomanText
\parencite{gotham2019romantext} files into scores of \emph{block
chord} realizations.

\begin{figure}
 \centerline{\includegraphics[width=\columnwidth]{figs/texturization.png}}
 \caption{Example of texturization. The \emph{block chord}
 texture (b) was synthesized using music21
 \parencite{cuthbert_music21_2010} from an input RomanText file
 \parencite{gotham2019romantext}. The texturized output (c) was
 generated by recursively applying musical patterns to the
 \emph{block chord} scores. The three musical patterns of
 \emph{bass-split}, \emph{Alberti bass}, and
 \emph{syncopation} are indicated in measures 1--3,
 respectively. The original music score (a) is shown for
 reference: mm. 1--4 of Beethoven's Piano Sonata Op.2 No.1.}
 \label{fig:texturization}
\end{figure}

We found the default \emph{block chord} texture of the
synthetic examples to be only slightly beneficial for the
model, possibly because it did not capture the complex
texture of real keyboard music, for example. In order to
account for this difference, we artificially ``texturized''
the generated training examples, departing from the default
\emph{block chords}. The texturization process involved
applying three simple note patterns recursively. Figure
\ref{fig:texturization} shows an example of the
texturization patterns, alongside the original score and the
default \emph{block chords} provided by music21. We describe
the texturization patterns below.

\textbf{Bass-split (measure 1).} The original chord duration
is divided by half, playing the bass note in isolation
during the first half, followed by the remaining upper
notes.

\textbf{Alberti bass (measure 2).} A 4-note melodic pattern
with the contour lowest, highest, middle, highest.

\textbf{Syncopation (measure 3).} The highest note is played
in isolation, followed by the remaining lower notes, played
in syncopation.

\textbf{Mixture (measure 4).} We applied these patterns
randomly and recursively. For example, the \emph{mixture} in
measure 4 displays a \emph{bass-split} pattern over the
whole-note chord, followed by a \emph{syncopation} pattern
applied over the three upper notes, in the second half of
the measure.

As part of the randomization, some chords were left
unaltered (e.g., the anacrusis of Figure
\ref{fig:texturization}), and the patterns were applied
across different duration values. To constraint the depth of
the recursion, we applied these patterns only to the slices
of the score that contained 3--4 simultaneous notes. This
process resulted in the generation of `new' pieces that
showed improvements in the learning process of the model,
further the than \emph{block chord} synthetic scores.
