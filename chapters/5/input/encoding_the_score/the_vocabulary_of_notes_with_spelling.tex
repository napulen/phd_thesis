% Copyright 2022 Néstor Nápoles López

Most tonal music analysis neural network models collapse all
enharmonic spellings of the same note, as shown in
\refeq{enharmonic_equivalence}.

\begin{equation}
    \label{eq:enharmonic_equivalence}
    \pitchFs = \pitchGb \quad \text{enharmonic equivalence}
\end{equation}

\begin{equation}
    \label{eq:enharmonic_nonequivalence}
    \pitchFs \neq \pitchGb \quad \text{enharmonic nonequivalence}
\end{equation}

In the \gls{arna} model proposed here, however, the spelling
of a pitch is encoded and taken into account, as shown in
\refeq{enharmonic_nonequivalence}. Two methods are described
to encode pitch spellings in this way.

%  and encode each of those spelling classes as one
% dimension in a vector. This method has been used in
% \textcite{micchi2020not, micchi2021deep}. An alternative
% method, proposed here, is to encode the pitch class and
% spelling of the pitch class. Both methods are described
% next.

\phdparagraph{35 one-hot encoding}

Perhaps the easiest method to encode a pitch spelling is to
assume that only a number of accidentals are allowed next to
a generic note letter (e.g., from \gls{doubleflat} to
\gls{doublesharp}). The use of \gls{sharp} and \gls{flat}
accidentals is very common. The use of \gls{doublesharp} and
\gls{doubleflat} accidentals is less common. Any accidental
sharper than \gls{doublesharp} or flatter than
\gls{doubleflat} is rare. Thus, a reasonable vocabulary for
spelled pitch classes\footnote{Note that the octave is
ignored.} is the one in \refeq{pitch_spelling_35}, with 35
classes. This method was used in \textcite{micchi2020not,
micchi2021deep} to encode the inputs of an \gls{arna} model.
Using this approach, a 35-dimensional pitch-spelling vector
is encoded every timestep, indicating the active pitch (or
pitches) of the 35 available classes.

\begin{equation}
    \label{eq:pitch_spelling_35}
    \begin{split}
    \setps{}_{35} = \{ & \pitchCbb, \pitchDbb, \pitchEbb, \pitchFbb, \pitchGbb, \pitchAbb, \pitchBbb, \\
    & \pitchCb, \pitchDb, \pitchEb, \pitchFb, \pitchGb, \pitchAb, \pitchBb, \\
    & \pitchC, \pitchD, \pitchE, \pitchF, \pitchG, \pitchA, \pitchB, \\
    & \pitchCs, \pitchDs, \pitchEs, \pitchFs, \pitchGs, \pitchAs, \pitchBs, \\
    & \pitchCx, \pitchDx, \pitchEx, \pitchFx, \pitchGx, \pitchAx, \pitchBx \}
    \end{split}
\end{equation}

\begin{equation}
    \label{eq:pitch_spelling_35_magnitude}
    | \setps{}_{35} | = 35
\end{equation}

\phdparagraph{19 two-hot encoding}

One of the problems with the previous representation of 35
features is that the it cannot encode any notes beyond two
flats or two sharps. Additionally, the resulting vector is
almost three times larger than the common representation
based on pitch classes, which has 12 features:\footnote{When
enharmonic equivalence is assumed in a \gls{12tet} system, a
set of 12 pitch classes spans all the note classes of the
Western chromatic scale.}

\begin{equation}
    \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\}
\end{equation}

The representation, first proposed in
\textcite{napoleslopez2021augmentednet}, reduces some of the
problems with the representation of 35 features. Instead of
encoding \gls{sharp} and \gls{flat} notes explicitly, it
extends the pitch class vector representation, by also
encoding the generic note letter name:

\begin{equation}
    \label{eq:pitch_spelling_19}
    \setps_{19} = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\} 
    \cup \{C, D, E, F, G, A, B\}
\end{equation}


\begin{equation}
    \label{eq:pitch_spelling_19_magnitude}
    | \setps_{19} | = 19
\end{equation}

Note that in this representation, in addition to the pitch
class, a spelled note has a corresponding letter. For
example, C\musSharp{} is represented by the duple $(1,
\text{C})$, where as D\musFlat{} is represented by the same
pitch class but a different generic note letter, $(1,
\text{D})$. D$\musNatural{}$ has the same generic note
letter but a different pitch class, $(2, \text{D})$, and so
on. Using this representation, a spelled note, beyond two
flats and two sharps can be encoded with a 19-feature
vector. Notice, however, that this vector is a two-hot
encoding representation.
