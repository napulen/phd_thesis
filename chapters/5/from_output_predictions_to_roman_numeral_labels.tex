% Copyright 2022 Néstor Nápoles López

Although the predictions provided by the \gls{crnn} are
crucial to determine the \gls{rna} labels generated by the
\gls{arna} model, there is another important step left,
which is to turn those predictions into \gls{rna} labels.
% Two methods for interpreting the predictions were
% designed: a preference rule and an approach based on
% cosine similarity and the algorithm in
% \refsec{analgorithmtoresolveromannumeralsfromapitch-classsetandkey}.

As mentioned in
\refsec{thestructureofaromannumeralanalysislabel}, a Roman
numeral label $\elrna \in \setrna$ could be defined as a
string with four components: a key $\elkey \in \setkey$, a
numerator $\elnum \in \setnum$, a tonicization (denominator)
$\elden \in \setden$, and an inversion $\elinv \in \setinv$,
as shown in \refeq{rna}. Thus, if those four pieces of
information are known, a \gls{rna} label that conforms to
this structure can be generated.

\begin{equation}
    \label{eq:rna}
    \elrna = \elkey : \elnum^{\elinv} \; / \; \elden
\end{equation}

Consider the following predictions coming from the
\gls{crnn} for the same musical fragment shown in
\reffig{schumann}.



The key $\elkey$ corresponds to the prediction of the
\gls{localkey38} classification task. The numerator $\elnum$
corresponds to the prediction of the \gls{rn31}
classification task. The tonicization $\elden$ corresponds
to the prediction of the \gls{tonicization38} classification
task. The inversion $\elinv$ corresponds to the prediction
of the \gls{bass35} note in the context of the numerator
$\elnum$. An initial approach could be to use the
predictions of the \gls{localkey38}, \gls{rn31}, and
\gls{tonicization38} tasks to generate the chord, and then
\gls{bass35} to retrieve the inversion.

% In order to generate the final \gls{rna} labels, an
% algorithm was designed to resolve them based on three
% pieces of information: \begin{enumerate} \item a
% \gls{pcset} $\rho \in \setpcset$ \item a key $k \in
% \setkey$ \item an inversion $i \in$ $\{$ $0$, $1$, $2$,
% $3$ $\}$ \end{enumerate}

% With these three pieces of information, the algorithm
% described in
% \refsec{analgorithmtoresolveromannumeralsfromapitch-classsetandkey}
% will produce a Roman numeral numerator $\elnum \in
% \setnum$.

% The purpose of the algorithm is to retrieve a numerator
% $\elnum$, however, this information is already present in
% the \gls{rn31} task, which is one of the classification
% outputs of the \gls{mtl} configuration. Why do we need an
% algorithm, then?

% The design of the algorithm served two purposes: to
% standardize the resolution of tonicizations in \gls{rna}
% labels, and to guarantee that a \gls{rna} label would be
% generated even when the predictions of the network
% resulted nonsensical.



% There is not a unique way to do this, because multiple
% tasks provide overlapping information. For example, the
% \gls{satb35} tasks and the \gls{pcset121} task can both be
% used to retrieve the chord. These different tasks are
% often advantageous in different musical situations. They
% might also require a different postprocessing.

% Thanks to the approach followed to resolve \gls{rna}
% labels from \gls{pcset}s and keys, these are the main two
% pieces of information needed from the predictions of the
% neural network to generate a final \gls{rna} string. There
% are, however, a few exceptions.

% The \gls{satb35}, \gls{pcset121}, and \gls{rn31} tasks can
% all be used to retrieve the \gls{pcset}.

% The rule-based system works as a series of conditions.

% The \gls{satb35} tasks are preferred as the source of the
% chord. That is, if the pitches form a valid chord in the
% vocabulary, that chord is assumed to be the 
