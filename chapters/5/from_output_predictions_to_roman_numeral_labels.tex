% Copyright 2022 Néstor Nápoles López

Although the predictions provided by the \gls{crnn} are
crucial to determine the \gls{rna} labels generated by the
\gls{arna} model, there is another important step left,
which is to turn those predictions into \gls{rna} labels.
% Two methods for interpreting the predictions were
% designed: a preference rule and an approach based on
% cosine similarity and the algorithm in
% \refsec{analgorithmtoresolveromannumeralsfromapitch-classsetandkey}.

As mentioned in
\refsec{thestructureofaromannumeralanalysislabel}, a Roman
numeral label $\elrna \in \setrna$ could be defined as a
string with four components: a key $\elkey \in \setkey$, a
numerator $\elnum \in \setnum$, a tonicization (denominator)
$\elden \in \setden$, and an inversion $\elinv \in \setinv$,
as shown in \refeq{rna}. Thus, if those four pieces of
information are known, a \gls{rna} label that conforms to
this structure can be generated.

\begin{equation}
    \label{eq:rna}
    \elrna = \elkey : \elnum^{\elinv} \; / \; \elden
\end{equation}

Two methods are proposed to retrieve these four pieces of
information from the predictions of a machine learning
model. The first one, the \emph{direct} method, is tightly
coupled with the configuration of the \gls{crnn} proposed
here. Particularly, it benefits from the \gls{mtl}
configuration and the chosen output tasks. The second method
is more generic. It can be used where only a ``chord label''
and a key are available, for example, in the predictions of
other \gls{arna} methods. In the second method, the
numerator $\elnum$ and tonicization $\elden$ need to be
estimated. Thus, I refer to the second method as the
\emph{indirect} method. The following sections describe the
process of generating a sequence of \gls{rna} labels in both
methods, given the predictions from
\reftab{crnn_predictions}.

\phdtable[Predictions from the \gls{crnn} for the Clara
Schumann example presented at the beginning of the
chapter]{crnn_predictions}


% The different components of the \gls{rna} string have a
% hierarchical structure. The tonicization $\elden$ is
% relative to the key $\elkey$. The numerator $\elnum$ is
% relative to the tonicized key $\elden$. The inversion
% $\elinv$ depends on the numerator $\elnum$, because the
% syntax of the inversion is different for triads and for
% seventh chords. Taking the hierarchical structure into
% account, the components of the \gls{rna} label need to be
% resolved in the following order:

% \begin{enumerate} \item Key $\elkey$ \item Tonicization
%     $\elden$ \item Numerator $\elnum$ \item Inversion
%     $\elinv$ \end{enumerate}

% The design of the algorithm served two purposes: to
% standardize the resolution of tonicizations in \gls{rna}
% labels, and to guarantee that a \gls{rna} label would be
% generated even when the predictions of the network
% resulted nonsensical.

% There is not a unique way to do this, because multiple
% tasks provide overlapping information. For example, the
% \gls{satb35} tasks and the \gls{pcset121} task can both be
% used to retrieve the chord. These different tasks are
% often advantageous in different musical situations. They
% might also require a different postprocessing.

% Thanks to the approach followed to resolve \gls{rna}
% labels from \gls{pcset}s and keys, these are the main two
% pieces of information needed from the predictions of the
% neural network to generate a final \gls{rna} string. There
% are, however, a few exceptions.

% The \gls{satb35}, \gls{pcset121}, and \gls{rn31} tasks can
% all be used to retrieve the \gls{pcset}.

